## JSX
JavaScript的语法扩展

JSX中中的JavaScript表达式需要放到一个{}中

JSX可以防止注入攻击，因为JSX的内容在渲染之前都被转换为字符串了

Babel会把JSX转译为一个React.createElement()函数调用
React.createElement()可以创建一个虚拟DOM元素，包括元素的标签、class、内容、子元素等

## 元素渲染
ReactDOM会更新DOM来与React元素保持一致
React元素开销小

使用React创建的元素会挂载到一个根DOM节点上，挂载在该节点上的所有内容都会由ReactDOM管理
使用ReactDOM.render()可以将React元素渲染到根DOM节点中

React元素是不可变对象，创建后不可更改其子元素或者属性
目前更新UI的唯一方式是创建一个新的元素，传入ReactDOM.render()

ReactDOM会将元素前后状态进行对比，然后只更新变化的部分

## 组件
两种方式创建组件：
- 函数组件
- class组件

JSX规范：组件名称要以大写字母开头，以小写字母的组件被视为原生DOM标签

函数组件
只接收props对象，并返回一个React元素
props是只读属性，不会更改入参的函数被称为“纯函数”

## state
state是私有的，完全受控于当前组件
注意：
- 不要直接修state，应该使用setState
- state的更新可能是异步的，setState可以接收回调函数作为参数，回调函数的参数可以是上一个state和此次props
- setState把更新结果合并到state中，替换修改的状态，保留未修改的状态

## 生命周期函数
render 组件挂载、更新之前
componentDidMount 组件挂载完成
componentWillUnmount 组件从DOM中移除之前

## 数据向下流动
React组件是单数据流

## 事件处理
事件命名规则：小驼峰
React中阻止默认行为：e.preventDefault()
不需要使用addEventListener，而是在元素初始渲染时添加监听器，并在组件初始化时声明事件处理函数
注意事件处理函数需要绑定this，可以使用bind()，也可以使用class fields语法，
不推荐在绑定事件处理函数时使用回调函数，为了避免将该回调函数作为props传入子组件时会进行额外的渲染

## 事件传参
传参：
1. onClick={this.foo.bind(this, 参数)}
2. onClick={(e) => this.foo(参数, e)} // 箭头函数传参时，如果需要事件对象e，需要作为第二个参数传递
接收：
foo (参数, e) {
  ……
}

## 条件渲染
1. 用if语句
通过变量值控制渲染哪个组件
在render中进行判断并渲染

2. &&
条件 && 需要渲染的组件

3. 三目运算符
条件 ? 组件1 : 组件2

4. 阻止组件渲染
对于无状态组件：return null
对于有状态组件：render () { return null }

通过return null来阻止组件渲染，组件的生命周期依然完整

## 列表 & Key
JavaScript中使用map()方法遍历数组
每一个遍历的item需要绑定一个Key值，Key用于React识别哪些元素改变了

## 状态提升
数据共享（多个组件数据同步）
多个input的value数据源来自于其共同父组件的state中的状态
通过onChange改变input数据时，将改变后的数据传递给父组件，父祖家更新state


